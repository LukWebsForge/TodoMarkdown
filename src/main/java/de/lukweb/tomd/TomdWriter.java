package de.lukweb.tomd;

import com.intellij.openapi.application.Application;
import com.intellij.openapi.application.ApplicationManager;
import com.intellij.openapi.command.WriteCommandAction;
import com.intellij.openapi.editor.CaretModel;
import com.intellij.openapi.editor.Document;
import com.intellij.openapi.editor.Editor;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.roots.ProjectFileIndex;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.PsiDocumentManager;
import com.intellij.psi.PsiFile;
import com.intellij.psi.PsiManager;
import com.intellij.psi.search.FileTypeIndex;
import com.intellij.psi.search.GlobalSearchScope;
import com.intellij.psi.search.PsiTodoSearchHelper;
import com.intellij.psi.search.TodoItem;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.VelocityEngine;
import org.intellij.plugins.markdown.lang.MarkdownFileType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.StringWriter;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;

public class TomdWriter {

    private static final String COMMENT_START = "Generated by TODO to Markdown";
    private static final String COMMENT_END = "End of TODO to Markdown";
    private static final String COMMENT_START_LOWER = COMMENT_START.toLowerCase();
    private static final String COMMENT_END_LOWER = COMMENT_END.toLowerCase();
    // https://superuser.com/a/285878
    private static final List<String> MARKDOWN_EXTENSIONS = Arrays.asList(
            "markdown",
            "mdown",
            "mkdn",
            "md",
            "mkd",
            "mdwn",
            "mdtxt",
            "mdtext",
            "text",
            "rmd"
    );

    public static boolean isMarkdownExtension(String extension) {
        if (extension == null) {
            return false;
        }

        return MARKDOWN_EXTENSIONS.contains(extension.trim().toLowerCase());
    }

    ///////////////////////// >

    private Logger logger;
    private TomdSettings settings;
    private Project project;

    public TomdWriter(TomdSettings settings, Project project) {
        this.logger = LoggerFactory.getLogger(getClass());
        this.settings = settings;
        this.project = project;
    }

    public void createUpdateSingle(Editor editor, PsiFile file) {
        String markdown = buildMarkdown(file);
        updateOrInsertInEditor(markdown, editor);
    }

    public int updateAll() {
        List<PsiFile> todoFiles = findAllMarkdownTodoFiles();
        PsiDocumentManager psiDocManager = PsiDocumentManager.getInstance(project);
        int updateCounter = 0;

        for (PsiFile file : todoFiles) {
            String markdown = buildMarkdown(file);
            Document document = psiDocManager.getDocument(file);
            if (document == null) {
                logger.warn("Couldn't find document for PsiFile: {}", file);
                continue;
            }
            if (updateInDocument(markdown, document)) {
                updateCounter++;
            }
        }

        return updateCounter;
    }

    private String buildMarkdown(PsiFile psiFile) {
        VelocityEngine velocityEngine = VelocityFactory.getEngine();
        PsiTodoSearchHelper searchHelper = PsiTodoSearchHelper.SERVICE.getInstance(project);
        PsiDocumentManager documentManager = PsiDocumentManager.getInstance(project);

        List<PsiFile> files = new ArrayList<>();
        HashMap<PsiFile, TodoItem[]> todoItemsMap = new HashMap<>();
        readAction(() -> {
            for (PsiFile file : searchHelper.findFilesWithTodoItems()) {
                files.add(file);
                todoItemsMap.put(file, searchHelper.findTodoItems(file));
            }
        });

        files.sort(Comparator.comparing(file -> file.getVirtualFile().getPath()));

        StringWriter writer = new StringWriter();
        for (int i = 0; i < files.size(); i++) {
            PsiFile file = files.get(i);

            // Skip this file
            if (file.equals(psiFile)) {
                continue;
            }

            Document document = documentManager.getDocument(file);
            if (document == null) {
                logger.warn("There's no document for the file {} - {}", file.getName(), file.getVirtualFile().getPath());
                continue;
            }

            VelocityContext fileContext = new VelocityContext();
            fileContext.put("name", file.getName());
            fileContext.put("path", relativePath(psiFile.getVirtualFile(), file.getVirtualFile()));
            fileContext.put("nl", "\n");
            velocityEngine.evaluate(fileContext, writer, "tomd-file-tmpl", settings.getState().getFilenameTemplate());
            writer.write('\n');

            for (TodoItem item : todoItemsMap.getOrDefault(file, new TodoItem[0])) {
                VelocityContext itemContext = new VelocityContext();
                itemContext.put("text", document.getText(item.getTextRange()));
                itemContext.put("pattern", item.getPattern().getPatternString());
                itemContext.put("nl", "\n");

                velocityEngine.evaluate(itemContext, writer, "tomd-item-tmpl", settings.getState().getTodoEntryTemplate());
                writer.write('\n');
            }

            if (i < files.size() - 1) {
                // file isn't the last one
                writer.write('\n');
            }
        }

        return writer.toString();
    }

    private void updateOrInsertInEditor(String markdown, Editor editor) {
        Document document = editor.getDocument();
        CaretModel caretModel = editor.getCaretModel();

        boolean updated = updateInDocument(markdown, document);
        if (!updated) {
            // Insert
            String mdWithComments = "<!-- " + COMMENT_START + " / Don't change this line" + "-->\n" +
                    markdown +
                    "<!-- " + COMMENT_END + " -->";

            int offset = caretModel.getPrimaryCaret().getOffset();
            WriteCommandAction.runWriteCommandAction(project, () -> {
                document.insertString(offset, mdWithComments);
            });

            caretModel.moveToOffset(offset + mdWithComments.length());
        }
    }

    private boolean updateInDocument(String markdown, Document document) {
        String docText = document.getText().toLowerCase();
        int commentStart = docText.indexOf(COMMENT_START_LOWER);
        int commentEnd = docText.indexOf(COMMENT_END_LOWER);

        if (commentStart >= 0 && commentEnd >= 0) {
            // Update
            int startLine = document.getLineNumber(commentStart);
            int endLine = document.getLineNumber(commentEnd);

            int startOffset = document.getLineEndOffset(startLine);
            int endOffset = document.getLineStartOffset(endLine);

            WriteCommandAction.runWriteCommandAction(project, () -> {
                document.replaceString(startOffset, endOffset, "\n" + markdown);
            });

            return true;
        } else {
            return false;
        }
    }

    private String relativePath(VirtualFile base, VirtualFile to) {
        Path basePath = Paths.get(base.getPath()).getParent();
        Path toPath = Paths.get(to.getPath());
        String relativeString = basePath.relativize(toPath).toString();

        return relativeString.replace('\\', '/');
    }

    // http://www.jetbrains.org/intellij/sdk/docs/basics/indexing_and_psi_stubs/file_based_indexes.html
    private List<PsiFile> findAllMarkdownTodoFiles() {
        List<PsiFile> psiFiles = new ArrayList<>();
        PsiManager psiManager = PsiManager.getInstance(project);

        readAction(() -> {
            Collection<VirtualFile> markdownFiles =
                    FileTypeIndex.getFiles(MarkdownFileType.INSTANCE, GlobalSearchScope.allScope(project));

            if (markdownFiles.isEmpty()) return;

            ProjectFileIndex projectFileIndex = ProjectFileIndex.getInstance(project);
            for (VirtualFile file : markdownFiles) {
                if (!projectFileIndex.isInContent(file)) continue;

                PsiFile psiFile = psiManager.findFile(file);
                if (psiFile == null) continue;

                String fileText = psiFile.getText().toLowerCase();
                boolean start = fileText.contains(COMMENT_START_LOWER);
                boolean end = fileText.contains(COMMENT_END_LOWER);

                if (!start || !end) continue;
                psiFiles.add(psiFile);
            }
        });

        return psiFiles;
    }

    private void readAction(Runnable runnable) {
        Application app = ApplicationManager.getApplication();
        if (app.isReadAccessAllowed()) {
            runnable.run();
        } else {
            app.runReadAction(runnable);
        }
    }


}
