package de.lukweb.tomd;

import com.intellij.notification.NotificationDisplayType;
import com.intellij.notification.NotificationGroup;
import com.intellij.notification.NotificationType;
import com.intellij.openapi.actionSystem.AnAction;
import com.intellij.openapi.actionSystem.AnActionEvent;
import com.intellij.openapi.actionSystem.PlatformDataKeys;
import com.intellij.openapi.command.WriteCommandAction;
import com.intellij.openapi.editor.CaretModel;
import com.intellij.openapi.editor.Document;
import com.intellij.openapi.editor.Editor;
import com.intellij.openapi.project.Project;
import com.intellij.openapi.vfs.VirtualFile;
import com.intellij.psi.PsiDocumentManager;
import com.intellij.psi.PsiFile;
import com.intellij.psi.search.PsiTodoSearchHelper;
import com.intellij.psi.search.TodoItem;
import org.apache.velocity.VelocityContext;
import org.apache.velocity.app.VelocityEngine;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.StringWriter;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;

public class TomdMenu extends AnAction {

    private static final String COMMENT_START = "Generated by TODO to Markdown";
    private static final String COMMENT_END = "End of TODO to Markdown";

    // https://superuser.com/a/285878
    private List<String> markdownExtensions = Arrays.asList(
            "markdown",
            "mdown",
            "mkdn",
            "md",
            "mkd",
            "mdwn",
            "mdtxt",
            "mdtext",
            "text",
            "Rmd"
    );
    private NotificationGroup notificationGroup;
    private TomdSettings settings;
    private Logger logger;

    public TomdMenu() {
        this.logger = LoggerFactory.getLogger(getClass());
        this.notificationGroup =
                new NotificationGroup("TodoMarkdown", NotificationDisplayType.BALLOON, false);
        this.settings = TomdSettings.getInstance();
    }

    @Override
    public void update(@NotNull AnActionEvent event) {
        VirtualFile virtualFile = event.getData(PlatformDataKeys.VIRTUAL_FILE);
        PsiFile psiFile = event.getData(PlatformDataKeys.PSI_FILE);
        Editor editor = event.getData(PlatformDataKeys.EDITOR);

        if (virtualFile == null || psiFile == null || editor == null) {
            event.getPresentation().setEnabled(false);
            return;
        }

        if (!markdownExtensions.contains(virtualFile.getExtension())) {
            event.getPresentation().setEnabled(false);
            return;
        }

        event.getPresentation().setEnabled(true);
    }

    @Override
    public void actionPerformed(@NotNull AnActionEvent event) {
        Project project = event.getData(PlatformDataKeys.PROJECT);
        PsiFile psiFile = event.getData(PlatformDataKeys.PSI_FILE);
        Editor editor = event.getData(PlatformDataKeys.EDITOR);

        if (project == null || psiFile == null || editor == null) {
            String notText = String.format(
                    "An error occured while getting the PlatformData ~ Project: %s PsiFile: %s Editor: %s",
                    project, psiFile, editor
            );
            showNotification(notText, NotificationType.ERROR);
            return;
        }

        String markdown = buildMarkdown(project, psiFile);
        writeToDocument(markdown, editor);
    }

    private String buildMarkdown(Project project, PsiFile psiFile) {
        VelocityEngine velocityEngine = VelocityFactory.getEngine();
        PsiTodoSearchHelper searchHelper = PsiTodoSearchHelper.SERVICE.getInstance(project);
        PsiDocumentManager documentManager = PsiDocumentManager.getInstance(project);

        List<PsiFile> files = Arrays.asList(searchHelper.findFilesWithTodoItems());
        files.sort(Comparator.comparing(file -> relativePath(psiFile.getVirtualFile(), file.getVirtualFile())));

        StringWriter writer = new StringWriter();
        for (int i = 0; i < files.size(); i++) {
            PsiFile file = files.get(i);

            // Skip this file
            if (file.equals(psiFile)) {
                continue;
            }

            Document document = documentManager.getDocument(file);
            if (document == null) {
                logger.warn("There's no document for the file {} - {}", file.getName(), file.getVirtualFile().getPath());
                continue;
            }

            VelocityContext fileContext = new VelocityContext();
            fileContext.put("name", file.getName());
            fileContext.put("path", relativePath(psiFile.getVirtualFile(), file.getVirtualFile()));
            fileContext.put("nl", "\n");
            velocityEngine.evaluate(fileContext, writer, "tomd-file-tmpl", settings.getState().getFilenameTemplate());
            writer.write('\n');

            TodoItem[] items = searchHelper.findTodoItems(file);
            for (TodoItem item : items) {
                VelocityContext itemContext = new VelocityContext();
                itemContext.put("text", document.getText(item.getTextRange()));
                itemContext.put("pattern", item.getPattern().getPatternString());
                itemContext.put("nl", "\n");

                velocityEngine.evaluate(itemContext, writer, "tomd-item-tmpl", settings.getState().getTodoEntryTemplate());
                writer.write('\n');
            }

            if (i < files.size() - 1) {
                // file isn't the last one
                writer.write('\n');
            }
        }

        return writer.toString();
    }

    private String relativePath(VirtualFile base, VirtualFile to) {
        Path basePath = Paths.get(base.getPath()).getParent();
        Path toPath = Paths.get(to.getPath());
        String relativeString = basePath.relativize(toPath).toString();

        return relativeString.replace('\\', '/');
    }

    private void writeToDocument(String markdown, Editor editor) {
        Document document = editor.getDocument();
        CaretModel caretModel = editor.getCaretModel();

        String docText = document.getText();
        int commentStart = docText.indexOf(COMMENT_START);
        int commentEnd = docText.indexOf(COMMENT_END);
        if (commentStart >= 0 && commentEnd >= 0) {
            int startLine = document.getLineNumber(commentStart);
            int endLine = document.getLineNumber(commentEnd);

            int startOffset = document.getLineEndOffset(startLine);
            int endOffset = document.getLineStartOffset(endLine);

            WriteCommandAction.runWriteCommandAction(editor.getProject(), () -> {
                document.replaceString(startOffset, endOffset, "\n" + markdown);
            });
        } else {
            String mdWithComments = "<!-- " + COMMENT_START + " / Don't change this line" + "-->\n" +
                    markdown +
                    "<!-- " + COMMENT_END + " -->";

            int offset = caretModel.getPrimaryCaret().getOffset();
            WriteCommandAction.runWriteCommandAction(editor.getProject(), () -> {
                document.insertString(offset, mdWithComments);
            });

            caretModel.moveToOffset(offset + mdWithComments.length());
        }
    }

    private void showNotification(String text, NotificationType type) {
        notificationGroup.createNotification(text, type).notify(null);
    }
}
